#!/bin/bash

export GIT_MERGE_AUTOEDIT=no
export GITEX_CONFIG=~/.git-extend
export wgit=$(which git) #wrapped git
shopt -s extglob

#----------------------------------COMPLETIONS-----------------------------------#
function gitex_complete() {
  case "${COMP_CWORD}" in
    1)
        #core commands:
        COMPREPLY=($(compgen -W "$(git help -a | grep "^  [a-z]")" -- "${COMP_WORDS[1]}"))

        local IFS=$'\n'
        for section in $(grep -Eom 2 '^##.*$' $BASH_SOURCE)
        do
          for cmd in $(sed -n "/^${section}\$/,/^\}\$/ p" $BASH_SOURCE | grep -Eo '[^ (]+\)\s+#.*$' | sed 's/) .*$//')
          do
            COMPREPLY+=($(compgen -W "$(echo "${cmd}" | tr '|' ' ')" -- "${COMP_WORDS[1]}"))
          done
        done
      ;;
    2)
        COMPREPLY=($(compgen -f  -- "${COMP_WORDS[${COMP_CWORD}]}" | xargs -I {} bash -c 'if [ -d {} ];then echo {}/;else echo {}; fi'))
        case "${COMP_WORDS[1]}" in
          context|ctx|go)
              COMPREPLY=()
              section="##Context Actions (context|ctx|go):"
              if [ -f ${GITEX_CONFIG} ];then
                source ${GITEX_CONFIG}
                #add contexts:
                COMPREPLY+=($(compgen -W "$(grep -E '="$' ${GITEX_CONFIG} | sed 's/="$//' | tr $'\n' ' ')" -- "${COMP_WORDS[2]}"))
                #add repos:
                COMPREPLY+=($(compgen -W "$(echo "${!current}" | sed -e '/^$/d' -e 's/\/.*\///g' | tr $'\n' ' ')" -- "${COMP_WORDS[2]}"))
              fi
            ;;
          svn)
              COMPREPLY=($(compgen -W "$($wgit svn 2>&1 | grep "^  [a-z]" | cut -d' ' -f3)" -- "${COMP_WORDS[2]}"))
              section="##SVN Actions:"
            ;;
          do|dob|mod|mob)
              COMPREPLY=($(compgen -W "$(git help -a | grep "^  [a-z]")" -- "${COMP_WORDS[2]}"))
            ;;
        esac

        if [ -n "${section}" ];then
          for cmd in $(sed -n "/^${section}\$/,/^\}\$/ p" $BASH_SOURCE | grep -Eo '[^ (]+\)\s+#.*$' | sed 's/) .*$//' | grep -Ev '[\$\*]')
          do
            COMPREPLY+=($(compgen -W "$(echo "${cmd}" | tr '|' ' ')" -- "${COMP_WORDS[2]}"))
          done
        fi
      ;;
    *)
        COMPREPLY=($(compgen -f  -- "${COMP_WORDS[${COMP_CWORD}]}" | xargs -I {} bash -c 'if [ -d {} ];then echo {}/;else echo {}; fi'))
      ;;
  esac
}
complete -o nospace -F gitex_complete git

#----------------------------------FUNCTIONS-----------------------------------#
function bash_prompt()
{
  local branch=$($wgit rev-parse --abbrev-ref HEAD 2>/dev/null)
  dirty=''
  if [ -n "$($wgit status --porcelain 2>/dev/null)" ]; then
    dirty='*'
  fi
  PS1="\w \[\033[32m\]$branch\[\033[36m\]$dirty\[\033[0m\]\$ "
}
PROMPT_COMMAND=bash_prompt

##Main:
function gitex() {
  #------------------------------------SETUP-------------------------------------#

  if [ -f ${GITEX_CONFIG} ];then
    source ${GITEX_CONFIG}
  else
    echo -e "\033[33mgitex first run...\033[0m"

    echo "  set pager, changing tab length"
      $wgit config --global core.pager 'less -x2'

    echo "  allow simple push/pull"
      $wgit config --global push.default simple # tracking ?

    echo "  setup colors..."
      $wgit config --global color.diff auto
      $wgit config --global color.branch auto
      $wgit config --global color.status auto

      $wgit config --global color.branch.current "yellow reverse"
      $wgit config --global color.branch.local yellow
      $wgit config --global color.branch.remote green

      $wgit config --global color.diff.whitespace "red reverse"

      $wgit config --global color.status.added yellow
      $wgit config --global color.status.changed green
      $wgit config --global color.status.untracked cyan

    #echo "  setup aliases..."

    touch ${GITEX_CONFIG}
    echo -e "\033[32mDONE\033[0m"
  fi

  #------------------------------------MAIN--------------------------------------#
  actions=$(sed -n "/^##Group Actions:\$/,/^\}\$/ p" $BASH_SOURCE | grep -Eo '[^ (]+\)\s+#.*$' | sed 's/).*$//' | tr $'\n' '|')

  case "$1" in
    help)
        $wgit $@
        if [ $# -gt 1 ];then
          return
        fi
        echo ""
        git ex
      ;;
    ex) #print this usage information
        echo -e "\033[1mExtended Git Usage:\033[0m git [\033[34;1mactions\033[0m]"

        grep -Eo '^##.*$' $BASH_SOURCE |
        while read section
        do
          echo ""
          echo -e "  \033[1m${section#\#\#}\033[0m"
          sed -n "/^${section}\$/,/^\}\$/ p" $BASH_SOURCE | grep -Eo '[^ (]+\)\s+#.*$' | \
          while read help
          do
            printf "    \033[34;1m%-15s\033[0m %s\n" "${help%%)*#*}" "${help#*#}"
          done
        done
        echo ""
      ;;
    com|cam|cc) #alias to commit -a -m
        shift
        if [ -n "$@" ];then
          $wgit commit -a -m "$@"
        else
          echo -e "\033[31mNo commit message specified\033[0m"
          return 1
        fi
      ;;
    co) #alias to checkout
        shift
        $wgit checkout $@
      ;;
    modified) #open dirty files in $EDITOR
        dir=$(pwd)
        local IFS=$'\n'
        files=$($wgit status -s)
        for file in $files
        do
          $EDITOR $dir/${file##* }
        done
      ;;
    wash) #pull and push
        url=$($wgit config --get svn-remote.svn.url)
        #git-svn repo?
        if [ -z "${url}" ];then
          branch=$($wgit rev-parse --abbrev-ref HEAD)
          $wgit pull origin $branch
          if [ -n "$($wgit status --porcelain)" ];then
            echo -e "\033[33munmerged changes\033[0m"
          else
            $wgit push origin $branch
          fi
        else
          $wgit svn rebase
          if [ -n "$($wgit status --porcelain)" ];then
            echo -e "\033[33munmerged changes\033[0m"
          else
            $wgit svn dcommit
          fi
        fi
      ;;
    giff) #show differences in order
        shift
        local IFS=$'\n'
        for line in $($wgit --no-pager log --oneline $@)
        do
          sha=${line%% *}
          echo -e "\033[33m${sha}\033[0m ${line#* }"
          $wgit --no-pager show --color ${sha} $@ | sed 's/^/  /'
        done | less -x2 -S #eval $($wgit config --get core.pager)
      ;;
    glog) #grep the log commit messages
        shift
        if [ -z "$@" ];then
          $wgit --no-pager log --oneline
        else
          $wgit --no-pager log --oneline --grep "$@"
        fi
      ;;
    sub|tree) #simplified subtree actions
        shift
        gitex_subtree $@
      ;;
    @(${actions}))
        export GITEX_BRANCH=$(set +e;$wgit rev-parse --abbrev-ref HEAD 2>/dev/null;set -e)
        gitex_action $@
      ;;
    context|ctx|go) #context handling
        shift
        gitex_context $@
      ;;
    tut) #open tutorial in $EDITOR
        $EDITOR ~/projects/resources/git/usage.sh
      ;;
    rev) #revert file(s) to HEAD
        shift
        $wgit checkout -- $@
      ;;
    svn) #git-svn extras
        shift
        gitex_svn $@
      ;;
    *|'')
        $wgit "$@"
      ;;
  esac
}

##Group Actions:
function gitex_action() {
  local ACTION=$1
  shift
  local ARGS=$@

  local OWD=$OLDPWD
  local start=$(pwd)

  for repo in $(echo ${!current})
  do
    repo=${repo//\~/$HOME}
    cd ${repo}
    repo=${repo##*/}
    local branch=$($wgit rev-parse --abbrev-ref HEAD)
    local dirty=''
    if [ -n "$($wgit status --porcelain)" ]; then
      local dirty='*'
    fi
    local output="\033[34;1m${repo}\033[0m \033[32;1m$branch\033[36m$dirty\033[0m"

    case "${ACTION}" in
      list) #list repos and branches in current context
          echo -e "${output}"
        ;;
      stats) #show status -s on repos in the current context
          echo -e "${output}"
          $wgit status -s
        ;;
      do) #exec git on repos in the current context
          echo -e "${output}"
          eval "git $ARGS 2>&1"
        ;;
      dob) #exec git on repos in the current context of the same branch as the CWD
          if [ "$BRANCH" == "$branch" ]; then
            echo -e "${output}"
            eval "git $ARGS 2>&1"
          fi
        ;;
      mod) #exec git on dirty repos in the current context
          if [ -n "$(git status --porcelain)" ]; then
            echo -e "${output}"
            eval "git $ARGS 2>&1"
          fi
        ;;
      mob) #exec git on dirty repos in the current context of the same branch as the CWD
          if [[ "$BRANCH" == "$branch" && -n "$(git status --porcelain)" ]]; then
            echo -e "${output}"
            eval "git $ARGS 2>&1"
          fi
        ;;
      with) #eval on repos in the current context replacing REPO
          echo -e "${output}"
          local ARGS=${ARGS//REPO/$repo}
          eval "$ARGS"
        ;;
      *)
        echo -e "\033[31mInvalid action:\033[0m ${ACTION}"
        cd $start
        OLDPWD=$OWD
        return 1
        ;;
    esac
  done
  cd $start
  OLDPWD=$OWD
}

function gitex_add_repo_to_context() {
  set +e
  local repo=$1
  local OWD=$OLDPWD
  cd ${repo}
  repo=$(basename $($wgit rev-parse --show-toplevel 2>/dev/null) 2>/dev/null)
  if [[ "$?" -eq 0 ]];then
    if grep -q "/${repo}\$" <<< "${repos}";then
      echo -e "\033[31mskipping\033[0m adding \033[34;1m${repo}\033[0m"
    else
      echo -e "\033[32madding\033[0m \033[34;1m${repo}\033[0m"
      #pwd only works here because git runs extensions from the top level
      repos="${repos}
$(pwd)"
      export ${current}="${repos}"
    fi
  else
    echo -e "\033[31minvalid repo\033[0m ${1}"
  fi
  cd - >/dev/null
  OLDPWD=$OWD
}

function gitex_remove_repo_from_context() {
  set +e
  local repo=$1
  local OWD=$OLDPWD
  cd ${repo}
  repo=$(basename $($wgit rev-parse --show-toplevel 2>/dev/null) 2>/dev/null)
  if [[ "$?" -eq 0 ]];then
    echo -e "\033[32mremoving\033[0m \033[34;1m${repo}\033[0m"
    repos=$(sed "/\/${repo}$/d" <<< "${repos}")
    export ${current}="${repos}"
  else
    echo -e "\033[31minvalid repo\033[0m ${1}"
  fi
  cd - >/dev/null
  OLDPWD=$OWD
}

##Context Actions (context|ctx|go):
function gitex_context()
{
  if [ $# -lt 1 ]; then
    local action='list'
  else
    local action=$1
    shift
  fi

  contexts=()
  contexts="$(grep -E '="$' ${GITEX_CONFIG} | sed 's/="$//')"
  context=$(echo "${contexts}" | tr $'\n' '|')
  repos=$(echo "${!current}" | sed '/^$/d')
  repo=$(echo "$repos" | sed 's/^.*\///' | tr $'\n' '|')

  case "$action" in
    list|get) #list contexts (default)
        for ctx in ${contexts}
        do
          if [ "$ctx" == "$current" ];then
            echo -e "\033[32m${ctx}\033[36m*\033[0m"
          else
            echo -e "\033[32m${ctx}\033[0m"
          fi
        done
        return
      ;;
    new) #create and use new context
        current="$1"
        shift
        contexts="${contexts}
${current}"
        declare ${current}="
"
        echo -e "\033[33mcreated and using\033[0m \033[32m${current}\033[0m"
      ;;
    set|use) #switch to context
        current="$1"
        shift
        echo -e "\033[33musing\033[0m \033[32m${current}\033[0m"
      ;;
    add) #add repo to current context
        if [ -n "$1" ];then
          while [ -n "$1" ]
          do
            gitex_add_repo_to_context $1
            shift
          done
        else
          gitex_add_repo_to_context $(pwd)
        fi
        declare ${current}="${repos}"
      ;;
    remove) #delete repo from current context
        if [ -n "$1" ];then
          while [ -n "$1" ]
          do
            gitex_remove_repo_from_context $1
            shift
          done
        else
          gitex_remove_repo_from_context $(pwd)
        fi
      ;;
    @(${context})) #switch to using this context
        current="$action"
        echo -e "\033[33musing\033[0m \033[32m${current}\033[0m"
      ;;
    @(${repo})) #cd to this repo
        repo=$(grep -Em 1 "${action}$" <<< "${repos}")
        echo -e "\033[33mentering\033[0m \033[32m${action}\033[0m"
        cd ${repo//\~/$HOME}
        return
      ;;
    *)
        echo -e "\033[31mInvalid context action:\033[0m $1"
        return 1
      ;;
  esac
  
  echo "current=\"${current}\"" > ${GITEX_CONFIG}
  for ctx in ${contexts}
  do
    echo "${ctx}=\"
$(echo "${!ctx}" | sed '/^$/d')
\"" >> ${GITEX_CONFIG}
  done
  echo "" >> ${GITEX_CONFIG}
}

##Subtree Actions (sub|tree):
function gitex_subtree()
{
  if [ $# -lt 1 ]; then
    local action='list'
  else
    local action=$1
    shift
  fi

  local OWD=$OLDPWD
  local repo=$($wgit rev-parse --show-toplevel 2>/dev/null)
  cd ${repo}
  local GITEX_SUBTREE=${repo}/.git-subtree

  case "$action" in
    list|get) #list subtrees (default)
        for line in $(cat ${GITEX_SUBTREE} 2>/dev/null)
        do
          local name=${line%%=*}
          local repo=${line#*=}
          local repo=${repo%,*}
          local branch=${line##*,}
          echo -e "\033[34;1m${name##*/}\033[0m ${repo} \033[32;1m${branch}\033[0m"
        done
      ;;
    add) #add a subtree repo
        if [ $# -lt 2 ]; then
          echo "Usage: git [sub|tree] add [url] [path within repo] [branch]"
        else
          local url=$1
          local path=$2
          local branch=${3:-master}
          git subtree add -P ${path} ${url} ${branch} --squash
          echo "${path}=${url},${branch}" >> ${GITEX_SUBTREE}
        fi
      ;;
    remove) #remove [subtree]
        sedi "/$1=/d" ${GITEX_SUBTREE} #requires ._osrc
      ;;
    pull|update) #update the named subtree
        case "${1}" in
          all|"")
              for line in $(cat ${GITEX_SUBTREE})
              do
                local name=${line%%=*}
                git sub update "${name##*/}"
              done
            ;;
          *)
              local line=$(grep "$1=" ${GITEX_SUBTREE})
              local name=${line%%=*}
              local repo=${line#*=}
              local repo=${repo%,*}
              local branch=${line##*,}
              echo -e "updating \033[34;1m${name##*/}\033[0m ${repo} \033[32;1m${branch}\033[0m"
              git subtree pull --prefix ${name} "${repo}" "${branch}" --squash
            ;;
        esac
      ;;
    *)
        echo -e "\033[31mInvalid subtree action:\033[0m $1"
        cd - >/dev/null
        OLDPWD=$OWD
        return 1
      ;;
  esac

  cd - >/dev/null
  OLDPWD=$OWD
}


##SVN Actions:
function gitex_svn()
{
  case "$1" in
    co) #Checkout remote branch and track
        shift
        local branch=$1
        shift
        repo=$($wgit rev-parse --show-toplevel 2>/dev/null)
        url=$($wgit config --get svn-remote.svn.url)

        revision=$(svn log --stop-on-copy ${url}/${repo##*/}/branches/${branch} | egrep "r[0-9]+" | head -1 | cut -d' ' -f1)
        echo -e "\033[32mFetching ${branch} from ${revision}\033[0m"
        git svn fetch -r ${revision#r} #${url}/${repo##*/}

        git branch ${branch} origin/${branch}
        git checkout ${branch}
      ;;
    push) #alias to dcommit
        $wgit svn dcommit
      ;;
    pull) #alias to rebase
        $wgit svn rebase
      ;;
    *) #git-svn
        $wgit svn "$@"
      ;;
  esac
}

function git() {
  if tty -s <&1; then
    source $BASH_SOURCE #keep gitex sourced for fast dev
  fi
  gitex "$@"
}